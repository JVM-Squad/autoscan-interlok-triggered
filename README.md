# interlok-triggered

[![GitHub tag](https://img.shields.io/github/tag/adaptris/interlok-triggered.svg)](https://github.com/adaptris/interlok-triggered/tags)
[![license](https://img.shields.io/github/license/adaptris/interlok-triggered.svg)](https://github.com/adaptris/interlok-triggered/blob/develop/LICENSE)
[![Actions Status](https://github.com/adaptris/interlok-triggered/actions/workflows/gradle-publish.yml/badge.svg)](https://github.com/adaptris/interlok-triggered/actions)
[![codecov](https://codecov.io/gh/adaptris/interlok-triggered/branch/develop/graph/badge.svg)](https://codecov.io/gh/adaptris/interlok-triggered)
[![CodeQL](https://github.com/adaptris/interlok-triggered/workflows/CodeQL/badge.svg)](https://github.com/adaptris/interlok-triggered/security/code-scanning)
[![Known Vulnerabilities](https://snyk.io/test/github/adaptris/interlok-triggered/badge.svg?targetFile=build.gradle)](https://snyk.io/test/github/adaptris/interlok-triggered?targetFile=build.gradle)
[![Closed PRs](https://img.shields.io/github/issues-pr-closed/adaptris/interlok-triggered)](https://github.com/adaptris/interlok-triggered/pulls?q=is%3Apr+is%3Aclosed)

The TriggeredChannel is something that has a very specific use case. It is a channel where the workflows are only started when an external event occurs; hence the name. Once the trigger is received, workflows are started, the channel waits for the workflows to do their thing, and then stops them afterwards and is then ready for the next trigger. It is designed to be wholly asynchronous, so no information is returned back to the trigger.

There are some subtle differences between a TriggeredChannel and a normal channel; the consumers inside each workflow should really be based around things that actively poll (i.e. AdaptrisPollingConsumer implementations) rather than consumers that wait for activity (like a JmsConsumer or the like, if you need JMS behaviour, there is JmsPollingConsumer). The polling implementation for each consumer should be a OneTimePoller rather than one of the other implementations. This type of channel also handles errors and events slightly differently. By default, the channel will supply its own message error handling implementation, rather than using the Adapter's (in this case a com.adaptris.core.triggered.RetryMessageErrorHandler, infinite retries at 30 second intervals); you can change it if you want, but it must still be an instance of com.adaptris.core.triggered.RetryMessageErrorHandler. The trigger itself could be anything you want, it has a consumer/producer/connection element, so you could listen for an HTTP request, or use a JmxChannelTrigger which registers itself as a standard MBean, so you can trigger it remotely via jconsole or the like.
